if (process.env.FS25_BOT_DISABLE_CERTIFICATE_VERIFICATION === "true") {
  process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0;
}

const _ = require("lodash");
const convert = require("xml-js");
const fetch = require("fetch-retry")(global.fetch);

const ConfigUtils = {
  getNumber: (envVar, defaultValue = 0, minValue = null) => {
    const value = parseInt(process.env[envVar], 10) || defaultValue;
    return minValue !== null ? Math.max(value, minValue) : value;
  },

  getString: (envVar, defaultValue = "") => {
    return process.env[envVar] || defaultValue;
  },

  getBoolean: (envVar, defaultValue = false) => {
    if (process.env[envVar] === undefined) return defaultValue;
    return process.env[envVar] === "true";
  },
};

const retries = ConfigUtils.getNumber("FS25_BOT_FETCH_RETRIES", 3, 1);
const retryDelay = ConfigUtils.getNumber(
  "FS25_BOT_FETCH_RETRY_DELAY_MS",
  2000,
  1
);

const utils = {
  getDefaultDatabase: () =>
    _.cloneDeep({
      server: {
        game: "",
        version: "",
        name: "",
        mapName: "",
        online: false,
        unreachable: false,
      },
      mods: {},
      careerSavegame: {
        money: 0,
        playTime: 0,
      },
    }),

  getTimestamp: () => `<t:${Math.floor(new Date().getTime() / 1000)}>`,

  formatMinutes: (minutes) => {
    const remainingDays = Math.floor(minutes / 1440);
    const remainingHours = Math.floor((minutes % 1440) / 60);
    const remainingMinutes = minutes % 60;

    let string = "";
    if (remainingDays > 0) {
      string += `${remainingDays} g√ºn `;
    }
    if (remainingDays > 0 || remainingHours > 0) {
      string += `${remainingHours} saat `;
    }
    return `${string}${remainingMinutes} dakika`;
  },

  getDataFromAPI: async () => {
    const errors = [];

    try {
      console.log("üîÑ API verisi alƒ±nƒ±yor...");
      
      // Her endpoint i√ßin ayrƒ± ayrƒ± kontrol et
      const serverStatsUrl = process.env.FS25_BOT_URL_SERVER_STATS;
      const careerSavegameUrl = process.env.FS25_BOT_URL_CAREER_SAVEGAME;
      
      console.log(`üì° Server Stats URL: ${serverStatsUrl}`);
      console.log(`üì° Career Savegame URL: ${careerSavegameUrl}`);

      const [serverStatsResponse, careerSavegameResponse] = await Promise.all([
        fetch(serverStatsUrl, {
          retries,
          retryDelay,
          body: null,
          method: "GET",
          timeout: 15000, // 15 saniye timeout (artƒ±rƒ±ldƒ±)
          headers: {
            'User-Agent': 'FS25-Discord-Bot/1.0',
            'Accept': 'application/xml, text/xml, */*'
          }
        }).catch(err => {
          console.error("‚ùå Server stats fetch hatasƒ±:", err.message);
          console.error("üìä Hata detaylarƒ±:", err.stack);
          errors.push(`Server stats API hatasƒ±: ${err.message} (URL: ${serverStatsUrl})`);
          return null;
        }),
        fetch(careerSavegameUrl, {
          retries,
          retryDelay,
          body: null,
          method: "GET",
          timeout: 15000, // 15 saniye timeout (artƒ±rƒ±ldƒ±)
          headers: {
            'User-Agent': 'FS25-Discord-Bot/1.0',
            'Accept': 'application/xml, text/xml, */*'
          }
        }).catch(err => {
          console.error("‚ùå Career savegame fetch hatasƒ±:", err.message);
          console.error("üìä Hata detaylarƒ±:", err.stack);
          errors.push(`Career savegame API hatasƒ±: ${err.message} (URL: ${careerSavegameUrl})`);
          return null;
        })
      ]);

      if (!serverStatsResponse || !careerSavegameResponse) {
        const errorMessage = `API yanƒ±t hatasƒ±: ${errors.join(", ")}`;
        console.error(`‚ùå ${errorMessage}`);
        throw new Error(errorMessage);
      }

      console.log(`‚úÖ Server stats status: ${serverStatsResponse.status}`);
      console.log(`‚úÖ Career savegame status: ${careerSavegameResponse.status}`);

      // HTTP durum kodlarƒ±nƒ± kontrol et
      if (!serverStatsResponse.ok) {
        const errorMsg = `Server stats HTTP ${serverStatsResponse.status}: ${serverStatsResponse.statusText}`;
        console.error(`‚ùå ${errorMsg}`);
        errors.push(errorMsg);
      }

      if (!careerSavegameResponse.ok) {
        const errorMsg = `Career savegame HTTP ${careerSavegameResponse.status}: ${careerSavegameResponse.statusText}`;
        console.error(`‚ùå ${errorMsg}`);
        errors.push(errorMsg);
      }

      if (errors.length > 0) {
        const errorMessage = `HTTP hatalarƒ±: ${errors.join(", ")}`;
        console.error(`‚ùå ${errorMessage}`);
        throw new Error(errorMessage);
      }

      // XML i√ßeriƒüini al
      const [serverStatsXml, careerSavegameXml] = await Promise.all([
        serverStatsResponse.text().catch(err => {
          console.error("‚ùå Server stats XML okuma hatasƒ±:", err.message);
          console.error("üìä Response headers:", Object.fromEntries(serverStatsResponse.headers));
          errors.push(`Server stats XML okuma hatasƒ±: ${err.message}`);
          return null;
        }),
        careerSavegameResponse.text().catch(err => {
          console.error("‚ùå Career savegame XML okuma hatasƒ±:", err.message);
          console.error("üìä Response headers:", Object.fromEntries(careerSavegameResponse.headers));
          errors.push(`Career savegame XML okuma hatasƒ±: ${err.message}`);
          return null;
        })
      ]);

      if (!serverStatsXml || !careerSavegameXml) {
        const errorMessage = `XML okuma hatalarƒ±: ${errors.join(", ")}`;
        console.error(`‚ùå ${errorMessage}`);
        throw new Error(errorMessage);
      }

      // XML i√ßeriƒüini doƒürula
      if (serverStatsXml.length === 0) {
        console.error("‚ùå Server stats XML bo≈ü");
        errors.push("Server stats XML bo≈ü");
      }
      
      if (careerSavegameXml.length === 0) {
        console.error("‚ùå Career savegame XML bo≈ü");
        errors.push("Career savegame XML bo≈ü");
      }

      // XML i√ßeriƒüini logla (kƒ±saltƒ±lmƒ±≈ü)
      console.log("üìÑ Server stats XML (ilk 200 karakter):", serverStatsXml.substring(0, 200));
      console.log("üìÑ Career savegame XML (ilk 200 karakter):", careerSavegameXml.substring(0, 200));

      // XML'i JSON'a d√∂n√º≈üt√ºr
      let serverStats, careerSavegame;

      try {
        serverStats = JSON.parse(convert.xml2json(serverStatsXml, { compact: true, ignoreComment: true, ignoreInstruction: true }));
        console.log("‚úÖ Server stats XML ba≈üarƒ±yla parse edildi");
      } catch (xmlError) {
        console.error("‚ùå Server stats XML parse hatasƒ±:", xmlError.message);
        console.error("üìä Problematik XML (ilk 500 karakter):", serverStatsXml.substring(0, 500));
        errors.push(`Server stats XML parse hatasƒ±: ${xmlError.message}`);
      }

      try {
        careerSavegame = JSON.parse(convert.xml2json(careerSavegameXml, { compact: true, ignoreComment: true, ignoreInstruction: true }));
        console.log("‚úÖ Career savegame XML ba≈üarƒ±yla parse edildi");
      } catch (xmlError) {
        console.error("‚ùå Career savegame XML parse hatasƒ±:", xmlError.message);
        console.error("üìä Problematik XML (ilk 500 karakter):", careerSavegameXml.substring(0, 500));
        errors.push(`Career savegame XML parse hatasƒ±: ${xmlError.message}`);
      }

      if (errors.length > 0) {
        const errorMessage = `XML parse hatalarƒ±: ${errors.join(", ")}`;
        console.error(`‚ùå ${errorMessage}`);
        throw new Error(errorMessage);
      }

      console.log("‚úÖ T√ºm API verileri ba≈üarƒ±yla alƒ±ndƒ± ve parse edildi");
      return {
        serverStats,
        careerSavegame,
      };

    } catch (error) {
      console.error("‚ùå getDataFromAPI genel hatasƒ±:", error.message);
      console.error("üìä Hata stack:", error.stack);
      
      // Hata tipine g√∂re daha a√ßƒ±klayƒ±cƒ± mesaj
      let detailedError = `API veri alma hatasƒ±: ${error.message}`;
      
      if (error.message.includes('timeout')) {
        detailedError += " (Sunucu yanƒ±t verme s√ºresini a≈ütƒ±)";
      } else if (error.message.includes('ECONNRESET')) {
        detailedError += " (Baƒülantƒ± resetlendi)";
      } else if (error.message.includes('ENOTFOUND')) {
        detailedError += " (Sunucu bulunamadƒ±)";
      } else if (error.message.includes('certificate')) {
        detailedError += " (SSL sertifika hatasƒ±)";
      }
      
      throw new Error(detailedError);
    }
  },

  parseData: ({ serverStats, careerSavegame: savegame }, previousServer) => {
    try {
      console.log("üîç Veri parse ediliyor...");

      // Temel doƒürulama
      if (!serverStats) {
        console.error("‚ùå serverStats verisi bulunamadƒ±");
        return null;
      }

      if (!savegame) {
        console.error("‚ùå careerSavegame verisi bulunamadƒ±");
        return null;
      }

      // Server verilerini kontrol et
      const serverAttributes = serverStats?.Server?._attributes;
      if (!serverAttributes) {
        console.error("‚ùå Server._attributes bulunamadƒ±");
        console.log("üìä Mevcut serverStats yapƒ±sƒ±:", JSON.stringify(serverStats, null, 2).substring(0, 500));
        return null;
      }

      const server = {
        game: serverAttributes.game || previousServer?.game || "Farming Simulator 25",
        version: serverAttributes.version || previousServer?.version || "Bilinmiyor",
        name: serverAttributes.name || previousServer?.name || "Bilinmiyor",
        mapName: serverAttributes.mapName || previousServer?.mapName || "Bilinmiyor",
        online: true,
        unreachable: false,
      };

      console.log("‚úÖ Server bilgileri parse edildi:", server);

      // Mod verilerini parse et
      let mods = {};
      if (serverStats.Server?.Mods?.Mod !== undefined) {
        const modData = serverStats.Server.Mods.Mod;
        const modArray = Array.isArray(modData) ? modData : [modData];

        mods = modArray
          .filter(mod => mod && mod._attributes) // Ge√ßersiz modlarƒ± filtrele
          .map((mod) => ({
            hash: mod._attributes.hash || "",
            text: mod._text || mod._attributes.name || "Bilinmiyor",
            name: mod._attributes.name || "",
            version: mod._attributes.version || "1.0.0.0",
            author: mod._attributes.author || "Bilinmiyor",
          }))
          .reduce((obj, item) => {
            if (item.hash) { // Sadece hash'i olan modlarƒ± ekle
              obj[item.hash] = item;
            }
            return obj;
          }, {});
      }

      console.log(`‚úÖ ${Object.keys(mods).length} mod parse edildi`);

      // Kariyer save verilerini parse et
      let careerSavegameData = {
        money: 0,
        playTime: 0,
      };

      if (savegame?.careerSavegame?.statistics) {
        const stats = savegame.careerSavegame.statistics;
        careerSavegameData = {
          money: parseInt(stats.money?._text || stats.money || 0, 10),
          playTime: parseInt(stats.playTime?._text || stats.playTime || 0, 10),
        };
      }

      console.log("‚úÖ Kariyer verileri parse edildi:", careerSavegameData);

      return {
        server,
        mods,
        careerSavegame: careerSavegameData,
      };

    } catch (error) {
      console.error("‚ùå parseData hatasƒ±:", error.message);
      console.error("üìä Hata detaylarƒ±:", error.stack);
      return null;
    }
  },

  getModString(newData, previousMods, dlc) {
    const characterLimit = dlc ? 300 : 1200;
    const modType = dlc ? "DLC" : "mod";
    const emoji = dlc ? ":cd:" : ":joystick:";

    const filteredNew = Object.fromEntries(
      Object.entries(newData.mods).filter(([, { name: modName }]) =>
        dlc ? modName.startsWith("pdlc_") : !modName.startsWith("pdlc_")
      )
    );
    const filteredPrevious = Object.fromEntries(
      Object.entries(previousMods).filter(([, { name: modName }]) =>
        dlc ? modName.startsWith("pdlc_") : !modName.startsWith("pdlc_")
      )
    );

    let string = "";

    const newMods = [];
    const updatedMods = [];
    Object.values(filteredNew)
      .sort((modA, modB) =>
        modA.text.toLowerCase().localeCompare(modB.text.toLowerCase())
      )
      .forEach((mod) => {
        if (!Object.prototype.hasOwnProperty.call(filteredPrevious, mod.hash)) {
          if (
            Object.values(filteredPrevious)
              .map(({ name: modName }) => modName)
              .includes(mod.name)
          ) {
            updatedMods.push(mod);
          } else {
            newMods.push(mod);
          }
        }
      });

    const removedMods = [];
    Object.values(filteredPrevious)
      .sort((modA, modB) =>
        modA.text.toLowerCase().localeCompare(modB.text.toLowerCase())
      )
      .forEach((mod) => {
        if (!Object.prototype.hasOwnProperty.call(filteredNew, mod.hash)) {
          if (
            !Object.values(updatedMods)
              .map(({ name: modName }) => modName)
              .includes(mod.name)
          ) {
            removedMods.push(mod);
          }
        }
      });

    let tempModsString = "";
    if (newMods.length > 0) {
      tempModsString += `${emoji} Sunucuya **${newMods.length}** ${modType} y√ºklendi; \n`;
      newMods.forEach(({ text, version: modVersion, author }) => {
        tempModsString += `- **${text} ${modVersion}** by ${author}\n`;
      });
    }

    if (updatedMods.length > 0) {
      tempModsString += `${emoji} Sunucuda **${updatedMods.length}** ${modType} g√ºncellendi; \n`;
      updatedMods.forEach(({ text, version: modVersion, author }) => {
        tempModsString += `- **${text} ${modVersion}** by ${author}\n`;
      });
    }

    if (removedMods.length > 0) {
      tempModsString += `${emoji} Sunucudan **${removedMods.length}** ${modType} kaldƒ±rƒ±ldƒ±; \n`;
      removedMods.forEach(({ text, version: modVersion, author }) => {
        tempModsString += `- **${text} ${modVersion}** by ${author}\n`;
      });
    }

    if (tempModsString.length > 0) {
      if (tempModsString.length <= characterLimit) {
        string += tempModsString;
      } else {
        if (newMods.length > 0) {
          string += `Sunucuya **${newMods.length}** ${modType} y√ºklendi.\n`;
        }
        if (updatedMods.length > 0) {
          string += `Sunucuda **${updatedMods.length}** ${modType} g√ºncellendi.\n`;
        }
        if (removedMods.length > 0) {
          string += `Sunucudan **${removedMods.length}** ${modType} kaldƒ±rƒ±ldƒ±.\n`;
        }
      }
    }

    return string;
  },

  /**
   * Sunucu durumunu kontrol eder
   * @param {string} url - Kontrol edilecek URL
   * @return {Promise<boolean>} - Sunucu eri≈üilebilir mi?
   */
  checkServerStatus: async (url) => {
    try {
      const response = await fetch(url, {
        method: "HEAD",
        timeout: 5000,
      });
      return response.ok;
    } catch (error) {
      console.error(`‚ùå Sunucu durumu kontrol hatasƒ± (${url}):`, error.message);
      return false;
    }
  },

  /**
   * G√ºvenli sayƒ± parse etme
   * @param {any} value - Parse edilecek deƒüer
   * @param {number} defaultValue - Varsayƒ±lan deƒüer
   * @return {number} - Parse edilmi≈ü sayƒ±
   */
  safeParseInt: (value, defaultValue = 0) => {
    if (value === null || value === undefined) return defaultValue;

    const parsed = parseInt(value, 10);
    return isNaN(parsed) ? defaultValue : parsed;
  },
};

module.exports = utils;